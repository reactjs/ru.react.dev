---
id: context
title: Контекст
permalink: docs/context.html
---

Контекст позволяет передавать данные через дерево компонентов без необходимости передавать пропсы на промежуточных уровнях.

В типичном React приложении данные передаются сверху-вниз (от родителя к дочернему компоненту) с помощью пропсов. Однако, этот способ может быть череcчур громоздким для некоторых типов пропсов (например выбранный язык, UI-тема), которые необходимо передавать во многие компоненты в приложении. Контекст предоставляет способ делится такими данными между компонентами без необходимости явно передавать пропсы через каждый уровень дерева.

- [Когда использовать контекст](#when-to-use-context)
- [Перед тем, как вы начнёте использовать контекст](#before-you-use-context)
- [API](#api)
  - [React.createContext](#reactcreatecontext)
  - [Context.Provider](#contextprovider)
  - [Class.contextType](#classcontexttype)
  - [Context.Consumer](#contextconsumer)
- [Примеры](#examples)
  - [Динамический контекст](#dynamic-context)
  - [Изменение контекста из вложенного компонента](#updating-context-from-a-nested-component)
  - [Использование нескольких контекстов](#consuming-multiple-contexts)
- [Предостережения](#caveats)
- [Устаревший API](#legacy-api)

## Когда использовать контекст {#when-to-use-context}

Контекст разработан для передачи данных, которые можно назвать "глобальными" для всего дерева React-компонентов (например текущий аутентифицированный пользователь, UI-тема или выбранный язык). В примере ниже мы вручную передаём `theme` проп, чтобы стилизовать компонент Button:

`embed:context/motivation-problem.js`

Используя контекст, мы можем избежать передачи пропсов в промежуточные компоненты:

`embed:context/motivation-solution.js`

## Перед тем, как вы начнёте использовать контекст {#before-you-use-context}

В первую очередь контекст используется, когда некоторые данные должны быть доступны во *многих* компонентах на разных уровнях вложенности. По возможности старайтесь его избегать, так как контекст усложняет повторное использование компонентов.

**Если вы хотите избавиться от передачи некоторых пропсов на множество уровней вниз, обычно [композиция компонентов](/docs/composition-vs-inheritance.html) является более простым решением, чем контекст.**

Например, давайте рассмотрим компонент `Page`, который передаёт `user` и `avatarSize` пропсы на несколько уровней вниз, чтобы глубоко вложенные компоненты `Link` и `Avatar` смогли их использовать:

```js
<Page user={user} avatarSize={avatarSize} />
// ... который рендерит ...
<PageLayout user={user} avatarSize={avatarSize} />
// ... который рендерит ...
<NavigationBar user={user} avatarSize={avatarSize} />
// ... который рендерит ...
<Link href={user.permalink}>
  <Avatar user={user} size={avatarSize} />
</Link>
```

Передача `user` и `avatarSize` пропсов вниз выглядит избыточной, так как в итоге только компонент `Avatar` реально использует их. Досадно и то, что если вдруг компоненту `Avatar` потребуется больше пропсов сверху, вам придётся также добавить их на все промежуточные уровни.

Один из способов решить эту проблему **без контекста** — [передать вниз сам компонент `Avatar`](/docs/composition-vs-inheritance.html#containment), в случае чего промежуточным компонентам не нужно знать о `user`:

```js
function Page(props) {
  const user = props.user;
  const userLink = (
    <Link href={user.permalink}>
      <Avatar user={user} size={props.avatarSize} />
    </Link>
  );
  return <PageLayout userLink={userLink} />;
}

// Теперь, это выглядит так:
<Page user={user} />
// ... который рендерит ...
<PageLayout userLink={...} />
// ... который рендерит ...
<NavigationBar userLink={...} />
// ... который рендерит ...
{props.userLink}
```

С этими изменениями, только корневой компонент `Page` знает о том, что компоненты `Link` и `Avatar` используют `user` и `avatarSize`.

Этот способ может сделать ваш код чище во многих случаях, уменьшая количество пропсов, которые вы должны передавать через ваше приложение, и давая больше контроля корневым компонентам. Однако, это решение не является верным в каждом случае. Перемещая больше сложной логики вверх по дереву, вы перегружаете вышестоящие компоненты.

Вы не ограничены в передаче строго одного компонента. Вы можете передать несколько дочерних компонентов или, даже, создать для них разные "слоты", [как показано здесь](/docs/composition-vs-inheritance.html#containment):

```js
function Page(props) {
  const user = props.user;
  const content = <Feed user={user} />;
  const topBar = (
    <NavigationBar>
      <Link href={user.permalink}>
        <Avatar user={user} size={props.avatarSize} />
      </Link>
    </NavigationBar>
  );
  return (
    <PageLayout
      topBar={topBar}
      content={content}
    />
  );
}
```

Этого паттерна достаточно для большинства случаев, когда вам необходимо отделить дочерний компонент от его промежуточных родителей. Вы можете пойти еще дальше, используя [рендер-пропсы](/docs/render-props.html), если дочерним компонентам необходимо взаимодействовать с родителем перед рендером.

Однако, иногда одни и те же данные должны быть доступны во многих компонентах на разных уровнях дерева и вложенности. Контекст позволяет распространить эти данные и их изменения на все компоненты ниже по дереву. Управление текущим языком, UI темой или кэшем данных — это пример тех случаев, когда реализация с помощью контекста будет проще использования альтернативных подходов.

## API {#api}

### `React.createContext` {#reactcreatecontext}

```js
const MyContext = React.createContext(defaultValue);
```

Создание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего `Provider` выше в дереве компонентов.

Аргумент `defaultValue` используется **только** в том случае, если для компонента нет подходящего `Provider` выше в дереве. Это может быть полезно для тестирования компонентов в изоляции без необходимости оборачивать их. Обратите внимание: если передать `undefined` в  `value` у `Provider`, компоненты, использующие этот контекст, не будут использовать `defaultValue`.

### `Context.Provider` {#contextprovider}

```js
<MyContext.Provider value={/* some value */}>
```

Каждый объект Контекста используется вместе с `Provider` компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.

Принимает `value` проп, который будут передан во все компоненты, использующие этот контекст и являющиеся потомками этого Provider компонента. Один Provider может быть связан с несколькими компонентами, потребляющими контекст. Так же Provider компоненты могут быть вложены друг в друга, переопределяя значение контекста глубже в дереве.

Все потребители, которые являются потомками Provider, будут повторно рендериться, как только `value` проп у Provider изменился. Потребитель будет ререндериться при изменении контекста, даже если его родитель, не использующий данный контекст, блокирует повторные рендеры с помощью `shouldComponentUpdate`.

Изменения определяются с помощью сравнения нового и старого значения, используя алгоритм, аналогичный [`Object.is`](//developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description).

> Примечание
>
> Способ, по которому определяются изменения, может вызвать проблемы при передачи объекта в `value`: смотрите [Предостережения](#caveats).

### `Class.contextType` {#classcontexttype}

```js
class MyClass extends React.Component {
  componentDidMount() {
    let value = this.context;
    /* выполнить побочный эффект на этапе монтирования, используя значение MyContext */
  }
  componentDidUpdate() {
    let value = this.context;
    /* ... */
  }
  componentWillUnmount() {
    let value = this.context;
    /* ... */
  }
  render() {
    let value = this.context;
    /* отрендерить что-то, используя значение MyContext */
  }
}
MyClass.contextType = MyContext;
```

В свойство класса `contextType` может быть назначен объект Контекста, созданный с помощью [`React.createContext()`](#reactcreatecontext). Это позволяет вам использовать ближайшее и актуальное значение указанного Контекста при помощи `this.context`. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.

> Примечание
>
> Вы можете подписаться только на один контекст, используя этот API. В случае, если вам необходимо использовать больше одного, смотрите [Использование нескольких контекстов](#consuming-multiple-contexts).
>
> Если вы используете эксперементальный [синтаксис публичных полей класса](https://babeljs.io/docs/plugins/transform-class-properties/), вы можете использовать **static** поле класса, чтобы инициализировать ваш `contextType`.


```js
class MyClass extends React.Component {
  static contextType = MyContext;
  render() {
    let value = this.context;
    /* отрендерить что-то, используя значение MyContext */
  }
}
```

### `Context.Consumer` {#contextconsumer}

```js
<MyContext.Consumer>
  {value => /* отрендерить что-то, используя значение контекста */}
</MyContext.Consumer>
```

`Consumer` — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в [функциональном компоненте](/docs/components-and-props.html#function-and-class-components).

`Consumer` принимает [функцию в качестве дочернего компонента](/docs/render-props.html#using-props-other-than-render). Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент `value` будет равен ближайшему (вверх по дереву) значению этого контекста, а именно `value` пропу Provider компонента. Если такого Provider компонента не существует, `value` аргумент будет равен значению `defaultValue`, которое было передано в `createContext()`.

> Примечание
>
> Для получения более детальной информации о паттерне "функция в качестве дочернего компонента", смотрите [рендер-пропсы](/docs/render-props.html).

## Примеры {#examples}

### Динамический контекст {#dynamic-context}

Более сложный пример динамических значений для UI темы:

**theme-context.js**
`embed:context/theme-detailed-theme-context.js`

**themed-button.js**
`embed:context/theme-detailed-themed-button.js`

**app.js**
`embed:context/theme-detailed-app.js`

### Изменение контекста из вложенного компонента {#updating-context-from-a-nested-component}

Довольно часто необходимо изменить контекст из компонента, который находится где-то глубоко в дереве компонентов. В этом случае вы можете добавить в контекст функцию, которая позволит потребителям изменить значение этого контекста:

**theme-context.js**
`embed:context/updating-nested-context-context.js`

**theme-toggler-button.js**
`embed:context/updating-nested-context-theme-toggler-button.js`

**app.js**
`embed:context/updating-nested-context-app.js`

### Использование нескольких контекстов {#consuming-multiple-contexts}

Чтобы сделать последующие рендеры (связанные с контекстом) быстрыми, React требует, чтобы каждый потребитель контекста был отдельным компонентом в дереве.

`embed:context/multiple-contexts.js`

Если два или более значений контекста часто используются вместе, возможно, вам стоит рассмотреть создание отдельного компонента, который будет передавать оба значения дочерним компонентам с помощью паттерна "рендер-пропс".

## Предостережения {#caveats}

Контекст использует сравнение по ссылкам, чтобы определить, когда запускать последующий рендер. Из-за этого существуют некоторые подводные камни, например непреднамеренные повторные рендеры потребителей, когда ререндериться родитель Provider компонента. В следующем примере, потребители будут ререндериться каждый раз в случае повторного рендера Provider компонента, потому что каждый раз будет создаваться новый объект, передаваемый в `value`:

`embed:context/reference-caveats-problem.js`

Один из вариантов решения этой проблемы — хранение этого объекта в состоянии родительского компонента:

`embed:context/reference-caveats-solution.js`

## Устаревший API {#legacy-api}

> Примечание
>
> В прошлом React имел только экспериментальный API контекстa. Старый API будет поддерживаться во всех 16.x релизах, но использующие его приложения должны перейти на новую версию. Устаревший API будет удалён в будущем крупном релизе React. Вы можете прочитать [документацию устаревшего контекста здесь](/docs/legacy-context.html).
