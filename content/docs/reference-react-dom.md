---
id: react-dom
title: ReactDOM
layout: docs
category: Reference
permalink: docs/react-dom.html
---

Если вы загружаете React с помощью тэга `<script>`, эти высокоуровневые API доступны через глобальный `ReactDOM`. Если вы используете ES6 с npm, вы можете написать `import ReactDOM from 'react-dom'`.Если вы используете ES5 с npm, вы можете написать `var ReactDOM = require('react-dom')`.

## Обзор {#overview}

Пакет `react-dom` предостваляет специфические DOM методы которые могут быть использованы на верхнем уровне вашего приложения и как лазейка для того чтобы выйти из модели React если вам будет нужно. Большинство из ваших компонентов не должны использовать этот модуль

- [`render()`](#render)
- [`hydrate()`](#hydrate)
- [`unmountComponentAtNode()`](#unmountcomponentatnode)
- [`findDOMNode()`](#finddomnode)
- [`createPortal()`](#createportal)

### Поддержка браузерами {#browser-support}

React поддерживает все популярные браузеры, включая Internet Explorer 9 and выше, хотя [иногда вам понадобятся некоторые полифиллы](/docs/javascript-environment-requirements.html) для более старых браузеров, например IE 9 или IE 10.

> Note
>
> Мы не поддерживаем более старые браузеры, которые не поддерживают ES5 методы, но вы можете обнаружить, что ваши программы работают в более старых браузерах если полифиллы вроде [es5-shim and es5-sham](https://github.com/es-shims/es5-shim) уже присутствуют на странице. Вы будете сами по себе, если решите пойти этой дорогой.

* * *

## Справочник {#browser-support}

### `render()`

```javascript
ReactDOM.render(element, container[, callback])
```

Производит рендер React элемента внутрь DOM в предоставленный `container` и возвращает [ссылку](/docs/more-about-refs.html) на компонент (или возвращает `null` для [компонентов без состояния](/docs/components-and-props.html#functional-and-class-components)).

Если React элемент был предварительно отрендерен в `container`, это произведёт его обновление и мутирует DOM по необходимости для того чтобы отражать последний React элемент.

Если предоставляется дополнительный колбэк, он будет выполнен после того, как компонент будет отрендерен или обновлен.

> Примечание:
>
> `ReactDOM.render()` управляет содержимым передаваемого вами узла контейнера. Любые существующие элементы DOM внутри заменяются при первом вызове. Более поздние вызовы используют алгоритм отслеживания изменений React DOM для эффективного обновления.
>
> `ReactDOM.render()` не изменяет узел контейнера (изменяет только дочерние элементы контейнера). Возможно вставить компонент в существующий узел DOM без перезаписи существующих дочерних элементов.
>
> `ReactDOM.render()` в настоящее время возвращает ссылку на корневой экземпляр `ReactComponent`. Однако использование этого возвращаемого значения является устаревшим
> и этого следует избегать, потому что в будущих версиях React компоненты могут отображаться асинхронно в некоторых случаях. Если вам нужна ссылка на корневой экземпляр `ReactComponent`, предпочтительным решением является прикрепить
> [ссылку на колбэк](/docs/more-about-refs.html#the-ref-callback-attribute) к корневому элементу.
>
> Использование `ReactDOM.render()` для поддержки контейнера отрендеренного на сервере устарел и будет удален в React 17. Используйте [`hydrate()`](#hydrate) вместо этого.

* * *

### `hydrate()` {#hydrate}

```javascript
ReactDOM.hydrate(element, container[, callback])
```

Тоже что и [`render()`](#render), но используется для гидратации контейнера, содержимое HTML которого было отрендеренного [`ReactDOMServer`](/docs/react-dom-server.html). React попытается присоединить прослушиватели событий к существующей разметке.

React ожидает, что отображаемый контент идентичен на сервере и клиенте. Он может исправлять различия в текстовом содержимом, но вы должны рассматривать несоответствия как ошибки и исправлять их. В режиме разработки React предупреждает о несоответствиях во время гидратации. Нет никаких гарантий, что различия атрибутов будут исправлены в случае несовпадений. Это важно по соображениям производительности, поскольку в большинстве приложений несоответствия встречаются редко, и поэтому проверка всей разметки будет непомерно дорогой.

Если атрибут отдельного элемента или текстовое содержимое неизбежно отличается на сервере и клиенте (например, отметка времени), вы можете отключить предупреждение, добавив `suppressHydrationWarning={true}` к элементу. Он работает только на один уровень в глубину и является лазейкой. Не злоупотребляйте этим. Если это не текстовый контент, React по-прежнему не будет пытаться его исправить, поэтому он может оставаться несовместимым до будущих обновлений.

Если вам преднамеренно нужно отрендерить что-то другое на сервере и клиенте, вы можете выполнить двухпроходный рендеринг. Компоненты, которые рендерят что-то другое на клиенте, могут читать переменную состояния, такую как `this.state.isClient`, которую вы можете установить в `true` в `componentDidMount()`. Таким образом, начальный этап рендеринга будет отображать тот же контент, что и сервер, избегая несовпадений, но дополнительный этап будет происходить синхронно сразу после гидратации. Обратите внимание, что этот подход замедлит ваши компоненты, потому что они должны рендерится дважды, поэтому используйте его с осторожностью.

Помните, что нужно помнить о пользовательском опыте на медленных соединениях. Код JavaScript может загружаться значительно позже исходного HTML-рендеринга, поэтому, если вы рендерите что-то другое только для клиента, переход может вызвать раздражение. Тем не менее, при правильном выполнении может оказаться полезным отобразить «оболочку» приложения на сервере и показать только некоторые дополнительные виджеты на клиенте. Чтобы узнать, как это сделать без проблем с разметкой, обратитесь к объяснению в предыдущем абзаце.

* * *

### `unmountComponentAtNode()` {#unmountcomponentatnode}

```javascript
ReactDOM.unmountComponentAtNode(container)
```

Удалите смонтированный компонент React из DOM и очистите его обработчики событий и состояние. Если в контейнере не было смонтировано ни одного компонента, вызов этой функции ничего не делает. Возвращает `true` если компонент был размонтирован и `false` если не было компонента для размонтирования.
* * *

### `findDOMNode()`  {#finddomnode}

> Примечание:
>
> `findDOMNode` это лазейка, используемая для доступа к базовому узлу DOM. В большинстве случаев использование этой лазейки не рекомендуется, поскольку она пробивает абстракцию компонента. [Это устарело в `StrictMode`.](/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)

```javascript
ReactDOM.findDOMNode(component)
```
Если этот компонент был смонтирован в DOM, он возвращает соответствующий элемент DOM браузера. Этот метод полезен для чтения значений из DOM, таких как значения полей формы и выполнения измерений DOM. **В большинстве случаев, вы можете присоеденить к реф к узлу DOM и избегать использования `findDOMNode` вовсе.**

Когда компонент рендерится в `null` или` false`, `findDOMNode` возвращает` null`. Когда компонент выполняет рендеринг в строку, `findDOMNode` возвращает текстовый узел DOM, содержащий это значение. Начиная с React 16, компонент может возвращать фрагмент с несколькими дочерними элементами, и в этом случае findDOMNode возвращает узел DOM, соответствующий первому непустому дочернему элементу.

> Примечание:
>
> `findDOMNode` работает только с монтированными компонентами (то есть компонентами, которые были размещены в DOM). Если вы попытаетесь вызвать это для компонента, который еще не был смонтирован (например, вызов `findDOMNode ()` в `render ()` для компонента, который еще не создан), будет сгенерировано исключение.
>
> `findDOMNode` не может быть использован с функциональными компонентами.

* * *

### `createPortal()` {#createportal}

```javascript
ReactDOM.createPortal(child, container)
```

Создает портал. Порталы предоставляют способ [отрендерить дочерние элементы в узле DOM, который существует вне иерархии компонента DOM](/docs/portals.html).
