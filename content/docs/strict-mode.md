---
id: strict-mode
title: Строгий режим
permalink: docs/strict-mode.html
---

`StrictMode` – инструмент для обнаружения потенциальных проблем в приложении. Как и `Fragment`, `StrictMode` не рендерит видимого UI. Этот режим активирует дополнительные проверки и предупреждения для своих потомков.

> Примечание:
>
> Проверки строгого режима работают только в режиме разработки; _они не оказывают никакого эффекта в продакшен сборке_.

Строгий режим может быть включён для любой части приложения. Например:
`embed:strict-mode/enabling-strict-mode.js`

В примере выше проверки строгого режима *не* будут выполняться для компонентов `Header` и `Footer`. Однако будут выполнены для `ComponentOne` и `ComponentTwo`, а также для всех их потомков.

На данный момент `StrictMode` помогает с:
* [Обнаружением компонентов с небезопасными методами жизненного цикла](#identifying-unsafe-lifecycles)
* [Предепреждением об использовании устаревшего строкового API для реф](#warning-about-legacy-string-ref-api-usage)
* [Предупреждением об использовании устаревшего метода findDOMNode](#warning-about-deprecated-finddomnode-usage)
* [Обраружением неожиданных побочных эффектов](#detecting-unexpected-side-effects)
* [Обнаружением устаревшего API контекста](#detecting-legacy-context-api)

Дополнительные проверки будут включены в будущие релизы React.

### Обнаружение компонентов с небезопасными методами жизненного цикла {#identifying-unsafe-lifecycles}

[В статье блога](/blog/2018/03/27/update-on-async-rendering.html) рассматриваются причины, почему некоторые методы жизненного цикла не безопасно использовать в асинхронных React приложениях. Если в приложении подключены сторонние библиотеки, то отследить использование этих методов довольно тяжело. К счастью, строгий режим помогает обнаружить их!

Когда включён строгий режим, React составляет список всех классовых компонентов, которые используют небезопасные методы жизненного цикла, и отображает информацию о них таким обрзаом:

![](../images/blog/strict-mode-unsafe-lifecycles-warning.png)

Решение проблем, выявленных в строгом режиме, позволит использовать все преимущества асинхронного рендеринга в будущих релизах React.

### Предепреждение об использовании устаревшего строкового API для реф {#warning-about-legacy-string-ref-api-usage}

Ранее React предоставлял два способа управления рефами: устаревший строковый API и колбэк API. Хотя строковые рефы были более удобным, он имел [несколько недостатков](https://github.com/facebook/react/issues/1373) и наша рекомендация заключалась в том, чтобы [использовать колбэк](/docs/refs-and-the-dom.html#legacy-api-string-refs).

React 16.3 добавил третий вариант, удобный как строковые рефы и без каких-либо недостатков:
`embed:16-3-release-blog-post/create-ref-example.js`

С тех пор как объекты-рефы были добавлены как замена строковых реф, строгий режим теперь предупреждает об использовании стоковых реф.

> **Примечание:**
>
> Колбэк рефы также поддерживаются в дополнеии к новому `createRef` API.
>
> Вам не нужно заменять обратные вызовы в ваших компонентах. Они немного более гибкие, поэтому останутся как продвинутая фича.
[Ознакомьтесь с новым `createRef` API здесь.](/docs/refs-and-the-dom.html)

### Предупреждение об использовании устаревшего метода findDOMNode {#warning-about-deprecated-finddomnode-usage}

Ранее React использовал `findDOMNode` для поиска DOM-узла в дереве по экземпляру класса. Обычно этот метод не используют, так как можно [привязать реф непосредственно к DOM-узлу](/docs/refs-and-the-dom.html#creating-refs).

`findDOMNode` можно было использовать с классовыми компонентами, однако это нарушало уровни абстракции, позволяя родительскому компоненту требовать рендера определённых дочерних элементов. Это создаёт опасность при рефакторинге, когда вы не можете изменить реализацию компонента, потому что родитель может попасть в его DOM-узел. `findDOMNode`  возвращает только первый дочерний элемент, но компонент может рендерить несколько DOM-узлов используя Фрагменты. `findDOMNode` – . Он возвращает результат, когда вы вызваете метод. Если дочерний компонент рендерит другой узел, то эти изменения не получится отследить. Следовательно, `findDOMNode` работает только тогда, когда компоненты всегда возвращают единственный DOM-узел, который никогда не изменяется.

Вместо этого, можно передать реф в компонент и далее передать его в DOM используя [перенаправление реф](/docs/forwarding-refs.html#forwarding-refs-to-dom-components).

Также можно использовать DOM-узел как обёртку в компоненте и прикрепить реф непосредственно к ней.

```javascript{4,7}
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.wrapper = React.createRef();
  }
  render() {
    return <div ref={this.wrapper}>{this.props.children}</div>;
  }
}
```

> Примечание:
>
> CSS атрибут [`display: contents`](https://developer.mozilla.org/ru/docs/Web/CSS/display#display_contents) может применяться для исключения узла из раскладки.

### Обраружение неожиданных побочных эффектов {#detecting-unexpected-side-effects}

React работает в две фазы:
* **Фаза рендера (render phase)** определяет какие изменения необходимо произвести в, например, DOM. В течении данной фазы, React вызывает `render`, затем сравнивает полученный результат с результатом предыдущего рендера.
* **Фаза фиксации (commit phase)** – в ней React применяет любые изменения. (В случае React DOM – это фаза, когда React вставляет, обновляет и удаляет DOM-узлы.) В течении этой фазы React вызывает методы жизненного цикла `componentDidMount` и `componentDidUpdate`.

Фаза фиксации обычно проходит быстро, однако фаза рендера может быть медленной. По этой причине, готовящийся асинхронный режим (который ещё не включён по умолчанию) делит работу рендера на части, останавливает и возобновляет работу для избежания блокировки браузера. Это означает, что React может выполнить фазу рендера lifecycles более, чем один раз перед фиксацией или может вызвать без фиксации совсем (по причине возникновения ошибки или более приоритетного прерывания).

Фаза рендера включает в себя следующие методы жизненного цикла:
* `constructor`
* `componentWillMount`
* `componentWillReceiveProps`
* `componentWillUpdate`
* `getDerivedStateFromProps`
* `shouldComponentUpdate`
* `render`
* `setState` функция обновления (первый аргумент)

Поскольку вышеупомянутые методы могут быть вызваны более одного раза, важно, чтобы они не содержали каких-либо побочных эффектов. Игнорирование этого правила может привести к множеству проблем, включая утечки памяти и некорректное состояние приложения. К сожалению, бывает довольно трудно обнаружить эти проблемы, поскльку они часто могу быть [недетерминированными](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC).

Строгий режим не может автоматически обнаружить побочные эффекты за нас, но помогает обнаружить их, сделав их немного более детерминированными. Это достигается путим преднамеренного двойного вызовва следующих методов:

* метод `constructor` классового компонента
* метод `render`
* `setState` функция обновления (первый аргумент)
* статически метод `getDerivedStateFromProps`

> Примечание:
>
> Это применимо только в режиме разработки. _Методы жизненного цикла не вызываются дважды в продакшен режиме._

К примеру, рассмотрим следующий код:
`embed:strict-mode/side-effects-in-constructor.js`

На первый взгляд данный пример может не показаться проблемным. Но если метод `SharedApplicationState.recordEvent` не является [идемпотентным](https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C#%D0%92_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B5), тогда при создании этого компонента несколько раз может привести к недопустимому состоянию приложения. Такой вид ошибок может не проявляться во время разработки, или она может быть непоследовательное и поэтому может быть проигнорирована.

Решение преднамеренно производить двойной вызов таких методов, как конструктор компонента, строгий режим облегчает поиск такого вида ошибок.

### Обнаружение устаревшего API контекста {#detecting-legacy-context-api}

Устаревший API контекста подвержен ошибкам и будет удалён в будущей мажорной версии. Он ещё доступен во всех релизах 16.x, но в строгом режиме будет выведено следующее предупреждение:

![](../images/blog/warn-legacy-context-in-strict-mode.png)

Ознакомьтесь с [документацией нового API контекста](/docs/context.html) для перехода на новую версию.
