---
id: strict-mode
title: Строгий режим
permalink: docs/strict-mode.html
---

`StrictMode` – инструмент для обнаружения потенциальных проблем в приложении. Также как и `Fragment`, `StrictMode` не рендерит видимого UI. Строгий режим активирует дополнительные проверки и предупреждения для своих потомков.

> Примечание:
>
> Проверки строгого режима работают только в режиме разработки; _они не оказывают никакого эффекта в продакшен сборке_.

Строгий режим может быть включён для любой части приложения. Например:
`embed:strict-mode/enabling-strict-mode.js`

В примере выше проверки строгого режима *не* будут выполняться для компонентов `Header` и `Footer`. Однако будут выполнены для `ComponentOne` и `ComponentTwo`, а также для всех их потомков.

На данный момент `StrictMode` помогает в:
* [Обнаружении небезопасных методов жизненного цикла](#identifying-unsafe-lifecycles)
* [Предупреждении об использовании устаревшего API строковых реф](#warning-about-legacy-string-ref-api-usage)
* [Предупреждении об использовании устаревшего метода findDOMNode](#warning-about-deprecated-finddomnode-usage)
* [Обраружении неожиданных побочных эффектов](#detecting-unexpected-side-effects)
* [Обнаружении устаревшего API контекста](#detecting-legacy-context-api)

Дополнительные проверки будут включены в будущих релизах React.

### Обнаружение небезопасных методов жизненного цикла {#identifying-unsafe-lifecycles}

[В данной статье блога](/blog/2018/03/27/update-on-async-rendering.html) рассматриваются причины, почему некоторые методы жизненного цикла небезопасно использовать в асинхронных React приложениях. Если в приложении подключены сторонние библиотеки, то отследить использование таких методов довольно тяжело. К счастью, строгий режим помогает сделать это!

Когда включён строгий режим, React составляет список всех классовых компонентов, которые используют небезопасные методы жизненного цикла, и отображает информацию о них таким образом:

![](../images/blog/strict-mode-unsafe-lifecycles-warning.png)

Если избавиться от проблем, выявленных в строгом режиме, _уже сегодня_, то это позволит получить все преимущества асинхронного рендеринга в будущих релизах React.

### Предупреждение об использовании устаревшего API строковых реф {#warning-about-legacy-string-ref-api-usage}

Ранее React предоставлял два способа управления рефами: устаревшие строковые рефы и колбэк API. Хотя строковые рефы и были более удобным способом, они имели [различные недостатки](https://github.com/facebook/react/issues/1373). Поэтому мы рекомендовали [использовать колбэки вместо них](/docs/refs-and-the-dom.html#legacy-api-string-refs).

React 16.3 добавил третий способ, удобный как строковые рефы и без каких-либо недостатков:
`embed:16-3-release-blog-post/create-ref-example.js`

Поскольку объекты-рефы были добавлены как замена строковых реф, строгий режим теперь предупреждает об использовании стоковых реф.

> **Примечание:**
>
> Колбэк-рефы по-прежнему поддерживаются вместе с новым `createRef` API.
>
> Вам не обязательно заменять колбэк-рефы в ваших компонентах. Их использование более гибкое, поэтому они считаются продвинутой возможностью.

[Ознакомьтесь с новым `createRef` API здесь.](/docs/refs-and-the-dom.html)

### Предупреждение об использовании устаревшего метода findDOMNode {#warning-about-deprecated-finddomnode-usage}

Ранее React использовал `findDOMNode` для поиска DOM-узла в дереве по указанному экземпляру класса. В большинстве случаев этот метод не используется, поскольку можно [привязать реф непосредственно к DOM-узлу](/docs/refs-and-the-dom.html#creating-refs).

`findDOMNode` может использоваться для классовых компонентов, однако это нарушает уровни абстракции, позволяя родительскому компоненту требовать, чтобы происходил рендер определённого дочернего элемента. Это приводит к проблемам при рефакторинге, когда не удаётся изменить детали реализации компонента, так как родитель может использовать DOM-узел этого компонента. `findDOMNode` возвращает только первый дочерний элемент, но с использованием фрагментов компонент может рендерить несколько DOM-узлов. `findDOMNode` выполняет поиск только один раз. Затем метод возвращает ранее полученный результат при вызове. Если дочерний компонент рендерит другой узел, то это изменение никак не отследить. Поэтому `findDOMNode` работает только когда компоненты возвращалют единственный и неизменяемый DOM-узел.

Вместо этого, можно передать реф в компонент и передать его далее в DOM используя [перенаправление реф](/docs/forwarding-refs.html#forwarding-refs-to-dom-components).

Также можно добавить компоненту DOM-узел как обёртку и прикрепить реф непосредственно к этой обёртке.

```javascript{4,7}
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.wrapper = React.createRef();
  }
  render() {
    return <div ref={this.wrapper}>{this.props.children}</div>;
  }
}
```

> Примечание:
>
> CSS атрибут [`display: contents`](https://developer.mozilla.org/ru/docs/Web/CSS/display#display_contents) может применяться для исключения узла из раскладки (layout).

### Обраружение неожиданных побочных эффектов {#detecting-unexpected-side-effects}

React работает в две фазы:
* **Фаза рендера (render phase)** определяет какие изменения необходимо произвести, например, в DOM. В течение этой фазы React вызывает `render`, а затем сравнивает полученный результат с результатом предыдущего рендера.
* **Фаза фиксации (commit phase)** – в ней React применяет любые изменения. (В случае React DOM – это фаза, когда React вставляет, обновляет и удаляет DOM-узлы.) В течении этой фазы React вызывает методы жизненного цикла `componentDidMount` и `componentDidUpdate`.

Фаза фиксации обычно не занимает много времени, что нельзя сказать про фазу рендера. По этой причине, готовящийся асинхронный режим (который по умолчанию ещё не включён) делит работу на части, периодически останавливает и возобновляет работу во избежании блокировки браузера. Это означает, что в фазе рендера React может вызвать методы жизненного цикла более чем один раз перед фиксацией, либо вызвать их без фиксации (по причине возникновения ошибки или прерывания с большим приоритетом).

Фаза рендера включает в себя следующие методы жизненного цикла:
* `constructor`
* `componentWillMount`
* `componentWillReceiveProps`
* `componentWillUpdate`
* `getDerivedStateFromProps`
* `shouldComponentUpdate`
* `render`
* `setState` функции обновления (первый аргумент)

Поскольку вышеупомянутые методы могут быть вызваны более одного раза, важно, чтобы они не приводили к каким-либо побочным эффектам. Игнорирование этого правила может привести к множеству проблем, включая утечки памяти и недопустимое состояние приложения. К сожалению, бывает очень трудно обнаружить эти проблемы, поскольку они часто могу быть [недетерминированными](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC).

Строгий режим не способен автоматически обнаруживать побочные эффекты, но помогает их отследить, сделав более детерминированными. Такое поведение достигается путём двойного вызова следующих методов:

* метод `constructor` классового компонента
* метод `render`
* `setState` функции обновления (первый аргумент)
* статически метод `getDerivedStateFromProps`

> Примечание:
>
> Это применимо только в режиме разработки. _Методы жизненного цикла не вызываются дважды в продакшен-режиме._

Рассмотрим следующий пример:
`embed:strict-mode/side-effects-in-constructor.js`

На первый взгляд данный пример не кажется проблемным. Но если метод `SharedApplicationState.recordEvent` не является [идемпотентным](https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C#%D0%92_%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B5), тогда создание этого компонента несколько раз может привести к недопустимому состоянию приложения. Такие труднонаходимые ошибки могут никак не проявить себя во время разработки или быть настолько редкими, что останутся незамеченными.

Дважды вызывая такие методы как конструктор компонента позволяет строгому режиму легко обнаружить такие проблемы.

### Обнаружение устаревшего API контекста {#detecting-legacy-context-api}

Использование устаревшего API контекста приводило к постоянным ошибкам и поэтому он будет удалён в будущей мажорной версии. Он ещё доступен во всех релизах 16.x, но в строгом режиме будет выведено следующее предупреждение:

![](../images/blog/warn-legacy-context-in-strict-mode.png)

Ознакомьтесь с [документацией нового API контекста](/docs/context.html), чтобы упростить переход на новую версию.
