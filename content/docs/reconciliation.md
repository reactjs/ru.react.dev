---
id: reconciliation
title: Cогласование
permalink: docs/reconciliation.html
---

React предоставляет декларативный API, который позволяет не беспокоиться о том, что именно изменяется при каждом обновлении. Благодаря этому, писать приложения становится намного проще, но может быть неочевидно как именно это реализовано внутри React. В этой статье объясняются решения, принятые нами для алгоритма сравнения в React, благодаря которому обновления компонента становятся предсказуемыми, и в то же время достаточно быстрыми для высокопроизводительных приложений.

## Мотивация {#motivation}

Во время использования React, в определённый момент времени вы можете думать о функции `render()`, как о создании дерева React элементов. При следующем обновлении состояния или пропсов, эта функция `render()` вернёт другое дерево React элементов. React должен понять как эффективно обновить UI, чтобы он совпадал с самым последним деревом.

Существует несколько общих решений алгоритмической проблемы трансформации одного дерева в другое за минимальное количество операций. Тем не менее, [передовые алгоритмы](http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf) имеют сложность порядка O(n<sup>3</sup>), где n — это число элементов в дереве.

Если бы мы использовали это в React, отображение 1000 элементов потребовало бы порядка миллиарда сравнений. Это слишком дорого. Взамен, React выполняет эвристический O(n) алгоритм основанный на двух предположениях:

1. Два элемента с разными типами произведут разные деревья.
2. Разработчик может указать, какие дочерние элементы могут оставаться стабильными сквозь разные рендеры с помощью пропа `key`.

На практике эти предположения верны почти для всех случаев.

## Алгоритм сравнения {#the-diffing-algorithm}

При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов.

### Элементы различных типов {#elements-of-different-types}

Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. Переходы от `<a>` к `<img>`, или от `<Article>` к `<Comment>`, или от `<Button>` к `<div>` приведут к полному перестроению.

При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают `componentWillUnmount()`. При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают `componentWillMount()`, а затем `componentDidMount()`. Любое состояние, связанное со старым деревом, теряется.

Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится. Например, при сравнении: 

```xml
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
```

При этом старый `Counter` уничтожится и перемонтируется новый.

### DOM-элементы одного типа {#dom-elements-of-the-same-type}

При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе DOM-узел и обновляет только изменённые атрибуты. Например:

```xml
<div className="before" title="stuff" />

<div className="after" title="stuff" />
```

Сравнивая эти элементы, React знает, что нужно модифицировать только `className` у лежащего в основе DOM-узла.

Обновляя `style`, React также знает, что нужно обновлять только изменившиеся свойства. Например: 

```xml
<div style={{color: 'red', fontWeight: 'bold'}} />

<div style={{color: 'green', fontWeight: 'bold'}} />
```

При конвертации между этими элементами, React знает, что нужно модифицировать только стиль `color`, а `fontWeight` сохранить.

После обработки DOM-узла React рекурсивно переходит к дочерним элементам.

### Компоненты одного типа {#component-elements-of-the-same-type}

Когда компонент обновляется, его экземпляр не меняется, чтобы его состояние сохранялось сквозь рендеры. React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает `componentWillReceiveProps()` и `componentWillUpdate()` на базовом экземпляре.

Далее вызывается метод `render()`, и алгоритм сравнения рекурсивно обходит предыдущий и новый результаты.

### Рекурсия по дочерним элементам {#recursing-on-children}

По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие.

Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично: 

```xml
<ul>
  <li>first</li>
  <li>second</li>
</ul>

<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

React сравнит два дерева `<li>first</li>`, сравнит два дерева `<li>second</li>`>, а затем вставит дерево `<li>third</li>`.

Если попробовать реализовать это наивно, вставив элемент в начало, то пострадает производительность. Например, преобразование между этими деревьями работает плохо: 

```xml
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```
React будет мутировать каждого потомка, вместо того чтобы оставить `<li>Duke</li>`  и `<li>Villanova</li>` нетронутыми. Эта неэффективность может стать проблемой.

### Ключи {#keys}

Для решения этой проблемы React поддерживает атрибут `key`. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева. Например, если добавить `key` к неэффективному примеру выше, преобразование дерева станет эффективным:

```xml
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

Теперь React знает, что элемент с ключом `'2014'` — новый, а элементы с ключами `'2015'` и `'2016'` только что переместились.

На практике найти ключ обычно несложно. Элемент, который вы хотите отобразить, уже может иметь уникальный ID, и ключ может быть взят из ваших данных:

```js
<li key={item.id}>{item.name}</li>
```

Когда уникальное значение отсутствует, вы можете добавить новое свойство ID в вашу модель или прохешировать данные, чтобы сгенерировать ключ. Ключ должен быть уникальным только среди его соседей, а не глобально.

В крайнем случае вы можете передать индекс элемента массива в качестве ключа. Это работает хорошо в случае, если элементы никогда не меняют порядок. Перестановки элементов вызывают замедление.

При использовании ключей перестановки так же могут вызывать проблемы с состоянием компонента. Экземпляры компонента обновляются и переиспользуются на основе их ключей. Перемещение элемента изменяет его, если ключ является индексом. В результате состояние компонента для таких вещей, как неконтролируемые инпуты, может смешаться и обновиться неожиданными способами.

[Здесь](codepen://reconciliation/index-used-as-key) на CodePen есть примеры проблем, которые могут быть вызваны использованием индексов в качестве ключей, а [здесь](codepen://reconciliation/no-index-used-as-key) обновлённая версия того же примера, которая показывает как проблемы с перестановкой, сортировкой и вставкой элементов в начало исправятся, если не использовать индексы как ключи.

## Компромиссы {#tradeoffs}

Важно помнить, что алгоритм согласования — это деталь реализации. React может повторно рендерить всё приложение на каждое действие, конечный результат будет тем же. Для ясности, повторный рендер в этом контексте означает вызов функции `render` для всех компонентов, но это не означает, что React размонтирует и смонтирует их заново. Он применит различия только следуя правилам, которые были обозначены в предыдущих разделах.

Мы регулярно совершенствуем эвристику, чтобы ускорить часто встречающиеся варианты использования. В текущей реализации вы можете выразить факт того, что поддерево сдвинулось среди его соседей, но вы не можете сказать, что оно сдвинулось куда-то в другое место. Алгоритм повторно отрендерит всё поддерево.

React полагается на эвристику, следовательно, если предположения, на которых она основана, не соблюдены, пострадает производительность. 

1. Алгоритм не будет пытаться сопоставить поддеревья компонентов разных типов. Если вы заметите за собой что пытаетесь чередовать компоненты разных типов с очень схожим выводом, то желательно сделать их компонентами одного типа. На практике мы не выявили с этим проблем.

2. Ключи должны быть стабильны, предсказуемы и уникальны. Нестабильные ключи (например, произведённые с помощью `Math.random()`) вызовут необязательноe пересоздание многих экземпляров компонента и DOM-узлов, что может вызывать ухудшение производительности и потерю состояния у дочерних компонентов.
