---
id: thinking-in-react
title: Философия React
permalink: docs/thinking-in-react.html
redirect_from:
  - 'blog/2013/11/05/thinking-in-react.html'
  - 'docs/thinking-in-react-zh-CN.html'
prev: composition-vs-inheritance.html
---

По нашему мнению, React — отличный способ создания больших и быстрых веб-приложений на основе JavaScript. Он очень хорошо масштабировался для нас в Facebook и Instagram.

Одна из особенностей React — это то, как он предлагает думать о приложениях в процессе их создания. В этом руководстве мы покажем мысленный процесс создания таблицы продуктов с поиском на React.

## Начнем с макета {#start-with-a-mock}

Представьте, что у вас уже есть JSON API и макет дизайна сайта. Вот как он выглядит: 

![Mockup](../images/blog/thinking-in-react-mock.png)

Наш JSON API возвращает данные, которые выглядят так:

```
[
  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
```

## Шаг 1: Разобьём интерфейс на составляющие {#step-1-break-the-ui-into-a-component-hierarchy}

Первое, что нужно сделать — представить границы вокруг каждого компонента (и подкомпонента) в макете и дать им имена. Если вы работаете с дизайнерами, вполне возможно, что они уже как-то называют компоненты — вам стоит пообщаться! Так, слои в Photoshop отлично подходят для наименования React-компонентов.

Но как узнать, что является компонентом, а что нет? Всё очень просто: это похоже на то, как вы решаете, надо ли объявить функцию или объект. Можно применить [принцип единственной ответственности](https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности): каждый компонент по-хорошему должен заниматься какой-то одной задачей. Если в конечном итоге функционал компонента увеличивается, его следует разбить на более мелкие подкомпоненты.

Поскольку мы часто показываем модель данных JSON пользователю, вы обнаружите, что если ваша модель была построена правильно, то пользовательский интерфейс (а следовательно и структура компонентов) отобразятся надлежащим образом. Это связано с тем, что UI и модели данных имеют свойство соблюдать аналогичную *информационную архитектуру*, что значит — разделить интерфейс на составляющие не составит труда. Просто разбейте его на компоненты, каждый из которых отображает часть модели данных.

![Component diagram](../images/blog/thinking-in-react-components.png)

Здесь мы видим, что наше простое приложение состоит из пяти различных компонентов. Курсивом выделены данные, которые эти компоненты представляют.

  1. **`FilterableProductTable` (оранжевый):** контейнер, содержащий пример целиком
  2. **`SearchBar` (синий):** поле *пользовательского ввода*
  3. **`ProductTable` (зелёный):** отображает и фильтрует *список данных*, основанный на *пользовательском вводе*
  4. **`ProductCategoryRow` (голубой):** наименования *категорий*
  5. **`ProductRow` (красный):** отдельно взятый *товар*

При взгляде на компонент `ProductTable` несложно заметить, что заголовок таблицы ("Name" и "Price") сам по себе отдельным компонентом не является. Отделять его или нет — вопрос личного предпочтения. В данном примере мы решили не придавать этому особого значения и оставить заголовок частью большего компонента `ProductTable`, так как он является всего лишь малой частью общего *списка данных*. Тем не менее, если в будущем заголовок пополнится новыми функциями (например, возможностью сортировать товар), имеет смысл отделить его в самостоятельный компонент `ProductTableHeader`.

Теперь, когда мы определили компоненты в нашем макете, давайте расположим их по порядку подчиненности. Это просто. Компоненты, которые являются частью других компонентов, в иерархии отображаются как дочерние:

  * `FilterableProductTable`
    * `SearchBar`
    * `ProductTable`
      * `ProductCategoryRow`
      * `ProductRow`

## Шаг 2: Создадим статическую версию в React {#step-2-build-a-static-version-in-react}

<p data-height="600" data-theme-id="0" data-slug-hash="BwWzwm" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">Пример кода <a href="https://codepen.io/gaearon/pen/BwWzwm">Философия React: Шаг 2</a> на <a href="http://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

Теперь, когда все компоненты расположены в иерархическом порядке, самое время реализовать наше приложение. Самый легкий способ — создать версию, которая использует модель данных и отрисовывает интерфейс, но не предполагает никакой интерактивности. Разделять эти процессы полезно, поскольку написание статической версии требует много печатания и совсем немного мышления, в то время как создание интерактивности приложения подразумевает более глубокий мыслительный процесс и лишь долю рутинной печати. Рассмотрим почему.

Чтобы построить статическую версию приложения, отображающую модель данных, нам нужно создать компоненты, которые используют другие компоненты и передают данные через *пропсы*. *Пропсы* — это способ передачи данных от родителя к потомку. Если вы знакомы с понятием *состояния*, то для статической версии это как раз то, чего вам **использовать не нужно**. Состояние подразумевает собой данные, которые меняются со временем — интерактивность. Так как мы работаем над статической версией приложения, нам этого не нужно.

Написание кода вы можете начать как с больших компонентов (`FilterableProductTable`), так и с малых подкомпонентов (`ProductRow`). Более простые приложения удобнее начать с компонентов, находящихся выше по иерархии. В более сложных приложениях удобнее в первую очередь создавать и тестирование подкомпоненты.

В конце этого шага у вас на руках должна быть библиотека повторно используемых компонентов, которые отображают вашу модель данных. Так как это статическая версия, компоненты будут иметь только `render()` методы. Компонент выше по иерархии (`FilterableProductTable`) будет передавать модель данных через пропсы. Если вы внесете изменения в базовую модель данных и снова вызовете `ReactDOM.render()`, то увидите изменения интерфейса. Ничего сложного в отслеживании изменений и обновлении UI нет. Благодаря **одностороннему потоку данных** (или *односторонней привязке*), React выполняет данный процесс связанно и быстро. 

Если у вас остались вопросы по поводу исполнения данного шага, обратитесь к [документации React](/docs/).

### Небольшое отступление: пропсы vs состояние {#a-brief-interlude-props-vs-state}

Существует два типа "модели" данных в React: пропсы и состояние. Важно, чтобы вы понимали разницу между ними, в противном случае обратитесь к [официальной React документации](/docs/interactivity-and-dynamic-uis.html).

## Шаг 3: Определим минимальное (но полноценное) отображение состояния интерфейса {#step-3-identify-the-minimal-but-complete-representation-of-ui-state}

Чтобы сделать наш UI интерактивным, нужно внести изменения в базовую модель данных. В React это возможно с помощью **состояния**.

Чтобы правильно построить приложение, сначала нужно продумать необходимый набор данных изменяемого состояния. Главное тут следовать принципу разработки [DRY: *Don't Repeat Yourself* (рус. не повторяйся)](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself). Определите минимальное количество необходимого состояния, которое нужно вашему приложению, всё остальное вычисляйте при необходимости. Например, если вы создаете список дел, держите массив пунктов списка под рукой; отдельное состояние для перечисления вам не нужно. Если надо отобразить количество элементов в списке, просто используйте длину существующего массива.

Давайте перечислим все данные в нашем приложении. У нас есть:

  * Первоначальный список товаров.
  * Поисковый запрос, введённый пользователем.
  * Значение чекбокса.
  * Отфильтрованный список товаров.

Давайте рассмотрим каждую часть данных и определим, какая из них является состоянием. Задайте себе следующие три вопроса:

  1. Передаётся ли она от родителя через пропсы? Если это так, вероятно, это не состояние.
  2. Остается ли она неизменной со временем? Если это так, вероятно, это не состояние.
  3. Можете ли вы вычислить её на основании любой другой части состояния или пропсах в своём компоненте? Если это так, это не состояние.

Исходный список товаров передаётся через пропсы, так что состоянием он быть не может. Поисковый запрос и чекбокс меняются со временем и не могут быть вычислены, так что они вполне сойдут за состояние. Напоследок, отфильтрованный список товаров не является состоянием, его можно вычислить методом совмещения оригинального списка, поискового запроса и значения чекбокса.

В итоге, состоянием являются:

  * Поисковый запрос, введенный пользователем
  * Значение чекбокса

## Шаг 4: Определим, где должно находиться наше состояние{#step-4-identify-where-your-state-should-live}

<p data-height="600" data-theme-id="0" data-slug-hash="qPrNQZ" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">Пример кода <a href="https://codepen.io/gaearon/pen/qPrNQZ">Философия React: Шаг 4</a> на <a href="http://codepen.io">CodePen</a>.</p>

Итак, мы определили минимальный набор состояний приложения. Далее нам нужно выяснить, какой из компонентов *владеет* состоянием или изменяет его.

Помните: в React поток данных односторонний и сходит сверху вниз в иерархическом порядке. Изначально не совсем ясно, какой из компонентов должен владеть каким состоянием. **Зачастую это самая сложная часть для новичков.** Чтобы разобраться, следуйте этим инструкциям:

Для каждой части состояния в приложении:

  * Определите компоненты, которые рендерят что-то исходя из состояния.
  * Найдите общий главенствующий компонент (компонент расположенный над другими компонентами, которым нужно это состояние). 
  * Либо общий главенствующий компонент, либо любой компонент, стоящий выше по иерархии, должен содержать состояние.
  * Если вам не удаётся найти подходящий компонент, создайте один исключительно для состояния и разместите его выше по иерархии над общим главенствующим компонентом.

Давайте применим эту стратегию на примере нашего приложения:

  * Задача `ProductTable` — отфильтровать список товаров, основываясь на состоянии, а `SearchBar` — отобразить состояние для поискового запроса и чекбокса.
  * Общий главенствующий компонент для обоих — `FilterableProductTable`.
  * По идее, имеет смысл содержать текст фильтра и значение чекбокса в `FilterableProductTable`.

Итак, мы приняли решение расположить наше состояние в `FilterableProductTable`. Первое, что нужно сделать — добавить свойство `this.state = {filterText: '', inStockOnly: false}` в конструктор `FilterableProductTable`, чтобы отобразить начальное состояние нашего приложения. После этого передайте `filterText` и `inStockOnly` в `ProductTable` и `SearchBar` через пропсы. Напоследок, используйте пропсы для фильтрации строк в `ProductTable` и определения значений полей формы `SearchBar`.

Вы заметите изменения в поведении вашего приложения: задайте значение `"ball"` для `filterText` и обновите страницу. Вы увидите соответствующие изменения в таблице данных.

## Шаг 5: Добавим обратный поток данных {#step-5-add-inverse-data-flow}

<p data-height="600" data-theme-id="0" data-slug-hash="LzWZvb" data-default-tab="js,result" data-user="rohan10" data-embed-version="2" data-pen-title="Thinking In React: Step 5" class="codepen">Пример кода <a href="https://codepen.io/gaearon/pen/LzWZvb">Философия React: Шаг 5</a> на <a href="http://codepen.io">CodePen</a>.</p>

До этого момента мы создавали приложение, в котором функция пропсов и состояние предаются вниз по иерархии. Теперь мы обеспечим поток данных в обратную сторону: наша задача сделать так, чтобы компоненты формы в самом низу иерархии обновляли состояние в `FilterableProductTable`.

Поток данных в React — прямой, но в связи с этим нам потребуется немного больше кода, чем в традиционной двусторонней привязке данных.

Если вы попытаетесь ввести текст в поисковике или установить флажок в чекбоксе данной версии примера, то увидите, что React игнорирует любой ввод. Это преднамеренно, так как ранее мы приравняли значение пропа `value` в `input` к `state` в `FilterableProductTable`.

Подумайте, какая задача стоит перед нами теперь. Нам нужно, чтобы при изменениях поисковой формы, менялось состояние ввода. Так как компоненты должны обновлять только относящееся к ним состояние, `FilterableProductTable` будет передавать колбэки в `SearchBar`, который будет срабатывать при каждом обновлении состояния. Чтобы получать уведомления об изменениях элементов формы, мы можем использовать событие `onChange`. Колбэки, переданные через компонент `FilterableProductTable`, вызовут `setState()`, и приложение обновится.

Хоть и звучит сложно, но занимает это всего несколько строк кода. А прямой поток данных через приложение от этого не меняется.

## Вот и всё {#and-thats-it}

Надеемся, что данная информация поможет вам получить лучшее представление о том, как подойти к созданию компонентов и приложений в React. Хотя этот процесс и использует немного больше кода, помните, код читают чаще, чем пишут. А такой модульный и прямой код, как в нашем приложении, читается очень легко. Когда вы начнете создавать большие библиотеки компонентов, вы сможете по-настоящему оценить прямолинейность и связанность React, а повторно используемые компоненты сделают ваш код намного меньше. :)
