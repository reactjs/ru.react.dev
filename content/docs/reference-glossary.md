---
id: glossary
title: Словарь терминов React
layout: docs
category: Reference
permalink: docs/glossary.html

---

## Одностраничное приложение {#single-page-application}

Одностраничное приложение — это приложение, которое состоит из единственной HTML-страницы и прочих ресурсов (таких как JavaScript и CSS), необходимых для успешной работы. Любое взаимодействие с главной или последующими ей страницами не требует контакта с сервером, что значит — страница не требует перезагрузки.


Хоть React и позволяет создавать одностраничные приложения, это совсем не обязательно. React можно использовать для совершенствования небольших частей уже существующих сайтов, чтобы придать дополнительную интерактивность. Код, написанный в React, может мирно сосуществовать с разметкой отрендеренной на сервере с помощью PHP, или с любыми другими фронтенд-библиотеками. По сути, именно так React и используется в Facebook.

## ES6, ES2015, ES2016 и т.д. {#es6-es2015-es2016-etc}

Все эти акронимы относятся к самым последним версиям спецификации стандарта ECMAScript, реализацией которого является язык программирования JavaScript. Версия ES6 (также известная как ES2015) включает много дополнений к предыдущим версиям: стрелочные функции, классы, шаблонные строки, ключевые слова `let` и `const`. Более подробно о конкретных версиях вы можно узнать [тут](https://ru.wikipedia.org/wiki/ECMAScript).

## Компиляторы {#compilers}

Компилятор JavaScript принимает на вход JavaScript код, преобразует его и возвращает в изменённом формате. Самый известный случай использования — преобразование синтаксиса ES6 для поддержки в старых браузерах. При работе с React чаще всего используется [Babel](https://babeljs.io/)

## Бандлеры {#bundlers}

Бандлеры берут отдельные модули JavaScript и CSS и соединяют их в меньшее количество файлов, которые оптимзированы под браузеры. В работе с React чаще всего используются [Webpack](https://webpack.js.org/) и [Browserify](http://browserify.org/).

## Менеджер пакетов {#package-managers}

Менеджер пакетов — это инструмент, позволяющий управлять зависимостями в вашем проекте. [npm](https://www.npmjs.com/) и [Yarn](https://yarnpkg.com/) — менеджеры пакетов наиболее используемые в приложениях React. Оба являются клиентами реестра пакетов npm.

## CDN {#cdn}
Сеть доставки содержимого (англ. Content Delivery Network, CDN) — это сетевая инфраструктура, распространяющая кешированный, статический контент через сеть серверов по всему миру.

## JSX {#jsx}

JSX — расширение синтаксиса JavaScript. Этот синтаксис выглядит как язык шаблонов, но наделён всеми языковыми возможностями JavaScript. В результате компиляции JSX и вызова `React.createElement()` возникают простые объекты — «React-элементы». Чтобы ознакомиться с введением в JSX, [обратитесь к соответствующему разделу документации](/docs/introducing-jsx.html), а более подробную информацию про JSX вы можете найти [здесь](/docs/jsx-in-depth.html).

React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов. Например, в JSX атрибут `tabindex` станет `tabIndex`. В то время как атрибут `class` записывается как `className`, поскольку слово `class` уже зарезервировано в JavaScript:

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [Элементы](/docs/rendering-elements.html) {#elements}
React-элементы — это составляющие блоки React-приложений. Их можно перепутать с более известной концепцией «компонентов», но в отличие от компонента, элемент описывает то, что вы хотите увидеть на экране. React-элементы иммутабельны.

```js
const element = <h1>Hello, world</h1>;
```

Обычно, элементы не используются напрямую, а возвращаются компонентами.

## [Компоненты](/docs/components-and-props.html) {#components}

React-компоненты — это маленькие, повторно используемые части кода, которые возвращают React-элементы для отображения на странице.
Самый простой React-компонент — это простая функция JavaScript, которая возвращает элементы React:

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

Компоненты могуть быть классами ES6:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

Компоненты можно разбить на отдельные части в зависимости от выполняемой функции и использовать внутри других компонентов. Компоненты могут возвращать другие компоненты, массивы, строки и числа. Если какая-то часть интерфейса повторяется многократно (`Button`, `Panel`, `Avatar`) или сама по себе достаточно сложная (`App`, `FeedStory`, `Comment`), имеет смысл вынести её в независимый компонент. Имена компонентов всегда должны начинатся с заглавной буквы (`<Wrapper/>`, а **не** `<wrapper/>`). За более детальной информацией о рендеринге компонентов [обратитесь к соответствующему разделу документации](/docs/components-and-props.html#rendering-a-component).

### [`props`](/docs/components-and-props.html) {#props}

`props` (пропсы) — это входные данные React-компонентов, передаваемые от родительского компонента дочернему компоненту.

Помните, `props` предназначены только для чтения. Ни в каком случае их не следует изменять:

```js
// Неправильно!
props.number = 42;
```
Если вам нужно поменять значение в ответ на пользовательский ввод или ответ сервера, используйте `state` (состояние).

### `props.children` {#propschildren}

В любом компоненте доступны `props.children`. Это контент между открывающим и закрывающим тегом компонента. Например:

```js
<Welcome>Hello world!</Welcome>
```

Строка `Hello world!` доступна в `props.children` в компоненте `Welcome`:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

Для классовых компонентов используйте `this.props.children`:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`state`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

Компонент нуждается в `state`, когда данные в нём со временем изменяются. Например, компоненту `Checkbox` может понадобится состояние `isChecked`, а компоненту `NewsFeed` необходимо отслеживать посты при помощи состояния `fetchedPosts`.

Самая большая разница между `state` и `props` состоит в том, что `props` передаются от родителя потомку, а `state` управляется самим компонентом. Компонент не может воздействовать на `props`, но может изменять `state`.  Для этого он должен вызвать `this.setState()`. Только классовые компоненты могут иметь состояние.


Для каждой отдельной части изменяемых данных должен существовать только один компонент, который «управляет» изменением состояния. Не пытайтесь синхронизировать состояния двух разных компонентов. Вместо этого [поднимите оба этих состояния](/docs/lifting-state-up.html) до ближайшего компонента-родителя и передайте через пропсы необходимым дочерним компонентам. 

## [Методы жизненного цикла](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

Методы жизненного цикла — это настраиваемые функции, которые выполняются на различных этапах жизни компонента. Существуют специальные методы для первоначального рендеринга компонента в DOM ([монтирование](/docs/react-component.html#mounting)), его обновления, размонтирования и удаления.


 ## [Контролируемые](/docs/forms.html#controlled-components) и [неконтролируемые компоненты](/docs/uncontrolled-components.html)

В React существует два различных подхода для управления формами.

Элемент формы input, управляемый React — это *контролируемый компонент*. Когда пользователь вводит данные в управляемый компонент, обработчик события изменений приходит в действие, и ваш код определяет допустим ли ввод (повторно рендерясь с обновленныем значением). Если повторный рендеринг не происходит, элемент формы остаётся без изменений.

*Неконтролируемый компонент* работает как обычный элемент формы вне React. Когда пользователь вводит данные в поле формы (поле ввода, выпадающий список и т.д.), обновлённая информация отображается без помощи React. Однако, это также значит, что некоторые значения не могут быть применены.

В большинстве случаев вам следует использовать управляемые компоненты.


## [Ключи](/docs/lists-and-keys.html) {#keys}

«Ключ» – это специальный строковый атрибут, который нужно указывать при создании списка элементов. Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.

Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными во всём приложении или даже в общем компоненте.


Не используйте что-либо наподобие `Math.random()` как ключи. Необходимо создавать для ключей «стабильные идентификаторы» при повторных рендерингах, чтобы React мог определить когда элементы добавлены, удалены или переупорядочены. В идеале, ключи должны соответствовать уникальному и постоянному идентификатору поступающему из ваших данных, например `post.id`.

## [Рефы](/docs/refs-and-the-dom.html) {#refs}

React поддерживает особый атрибут, который можно прикрепить к любому компоненту. Атрибут `ref` может быть объектом, созданным при помощи [функции `React.createRef()`](/docs/react-api.html#reactcreateref) или колбэком, либо же строкой (устаревшее API). Когда в роли атрибута `ref` выступает колбэк, функция получает DOM-элемент, лежащий в основе компонента, или экземпляр класса (в зависимости от типа элемента) в качестве аргумента. Это позволяет вам иметь прямой доступ к элементу DOM или экземпляру компонента.

Используйте рефы в исключительных случаях. Если вы часто обращаетесь к рефам за помощью, ознакомьтесь с [нисходящим потоком данных](/docs/lifting-state-up.html).



## [События](/docs/handling-events.html) {#events}

Обработка событий в React-элементах имеет некоторые синтактические особенности:

* Обработчики событий в React именуются в стиле camelCase вместо нижнего регистра.
* С JSX вы передаёте функцию как обработчик события вместо строки.

## [Согласование](/docs/reconciliation.html) {#reconciliation}

Когда пропсы или состояние компонента изменяются, React сравнивает нововозвращённый и предыдущий отрендеренные элементы, и решает нужно ли обновлять DOM. Этот процесс называется «согласование» (reconciliation).
